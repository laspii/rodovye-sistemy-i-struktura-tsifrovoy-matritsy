<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Эзотерический Кроссворд</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Скрытый инпут для вызова клавиатуры на мобильных */
        #hidden-input {
            position: absolute;
            opacity: 0;
            top: -1000px;
            pointer-events: none;
        }
        /* Стили скроллбара */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #f1f1f1;
        }
        ::-webkit-scrollbar-thumb {
            background: #c7c7c7;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #a8a8a8;
        }
        .cell-anim {
            transition: background-color 0.2s, color 0.2s;
        }
        /* Запрет выделения текста для удобства игры */
        .no-select {
            user-select: none;
            -webkit-user-select: none;
        }
    </style>
</head>
<body class="bg-gray-50 text-slate-800 font-sans min-h-screen touch-manipulation">

    <!-- Скрытый инпут для ввода -->
    <input type="text" id="hidden-input" autocomplete="off" spellcheck="false">

    <div class="max-w-6xl mx-auto p-4">
        <!-- Header -->
        <header class="mb-6 flex flex-col md:flex-row justify-between items-center bg-white p-4 rounded-xl shadow-sm">
            <div>
                <h1 class="text-2xl font-bold text-indigo-700 flex items-center gap-2">
                    <!-- Icon Trophy -->
                    <svg xmlns="http://www.w3.org/2000/svg" width="32" height="32" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M6 9H4.5a2.5 2.5 0 0 1 0-5H6"/><path d="M18 9h1.5a2.5 2.5 0 0 0 0-5H18"/><path d="M4 22h16"/><path d="M10 14.66V17c0 .55-.47.98-.97 1.21C7.85 18.75 7 20.24 7 22"/><path d="M14 14.66V17c0 .55.47.98.97 1.21C16.15 18.75 17 20.24 17 22"/><path d="M18 2H6v7a6 6 0 0 0 12 0V2Z"/></svg>
                    Кроссворд "Родовые системы и структура цифровой матрицы"
                </h1>
                <p class="text-sm text-gray-500 mt-1">Отгадывай слова и используй механику "Быки и Коровы" для проверки</p>
            </div>
            <button id="restart-btn" class="mt-4 md:mt-0 px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-lg flex items-center gap-2 text-sm transition cursor-pointer">
                <!-- Icon RotateCcw -->
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 12a9 9 0 1 0 9-9 9.75 9.75 0 0 0-6.74 2.74L3 8"/><path d="M3 3v5h5"/></svg>
                Пересобрать
            </button>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-12 gap-8">
            
            <!-- Левая колонка: Сетка и управление -->
            <div class="lg:col-span-7 flex flex-col items-center">
                <!-- Контейнер сетки -->
                <div id="grid-container" class="bg-white p-4 rounded-xl shadow-lg overflow-auto max-w-full border border-gray-200 mb-6 relative no-select">
                    <!-- Сетка генерируется JS -->
                </div>

                <!-- Панель управления Быками и Коровами -->
                <div class="w-full max-w-md bg-white p-4 rounded-xl shadow border border-indigo-100">
                    <h3 class="font-semibold mb-2 text-indigo-900 flex items-center gap-2">
                        <!-- Icon HelpCircle -->
                        <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M9.09 9a3 3 0 0 1 5.83 1c0 2-3 3-3 3"/><path d="M12 17h.01"/></svg>
                        Проверка слова
                    </h3>
                    
                    <div id="control-panel-content">
                        <!-- Динамический контент панели -->
                        <p class="text-sm text-gray-400 italic">Выберите слово в сетке, чтобы проверить его.</p>
                    </div>

                    <!-- Сообщение об ошибке/успехе -->
                    <div id="game-message" class="hidden mt-4 p-3 rounded-lg text-sm border"></div>
                </div>
            </div>

            <!-- Правая колонка: Список вопросов -->
            <div class="lg:col-span-5 flex flex-col gap-4 h-[calc(100vh-150px)] overflow-y-auto pr-2" id="questions-list">
                <!-- Инструкция -->
                <div class="bg-yellow-50 border border-yellow-200 p-4 rounded-lg text-sm text-yellow-800 mb-2">
                    <h4 class="font-bold flex items-center gap-2">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><path d="M12 16v-4"/><path d="M12 8h.01"/></svg>
                        Как играть?
                    </h4>
                    <ul class="list-disc list-inside mt-1 space-y-1">
                        <li>Кликните по клетке, чтобы выбрать слово.</li>
                        <li>Вводите буквы с клавиатуры.</li>
                        <li>Если сомневаетесь — нажмите ссылку <strong>Видео-подсказка</strong>.</li>
                        <li>Используйте кнопку <strong>Проверить</strong>.</li>
                    </ul>
                </div>
                
                <!-- Список слов генерируется JS -->
                <div id="words-list-container" class="flex flex-col gap-4"></div>
            </div>
        </main>
    </div>

<script>
// --- ДАННЫЕ ---
const WORD_DATA = [
  {
    word: "СИСТЕМА",
    desc: "То, что рассматривается на занятии, связанное с родом, управляющее каналами.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=2"
  },
  {
    word: "РОД",
    desc: "Совокупность физических и звездных каналов, которые должны быть связаны на 100%.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=29"
  },
  {
    word: "ДУША",
    desc: "То, что спускается, заземляется и воплощается в тело.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=52"
  },
  {
    word: "ТРАВНИК",
    desc: "Пример звездного рода, который занимается сбором растений.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=105"
  },
  {
    word: "ДИНАСТИЯ",
    desc: "Семья, где из поколения в поколение занимаются одним чем-то (например, ювелиры).",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=148"
  },
  {
    word: "МАГ",
    desc: "Человек, который знает все обо всем и идет через знание и управление процессами.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=234"
  },
  {
    word: "ЗЕМЛЕДЕЛЕЦ",
    desc: "Пример рода, связанный с взаимодействием с землей (в него воплотился автор).",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=246"
  },
  {
    word: "ДНК",
    desc: "Спираль, которая служит примером соединения земного и звездного рода.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=368"
  },
  {
    word: "ИСТОК",
    desc: "Первородная энергия, которая спустилась на землю первой; также начало всех родов.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=442"
  },
  {
    word: "ТВОРЕЦ",
    desc: "Тот, кто стоит во главе всех родов в мироздании.",
    videoUrl: "https://youtu.be/ufn7K9H3Nlc?t=1481"
  }
];

// --- СОСТОЯНИЕ ПРИЛОЖЕНИЯ ---
const state = {
    layout: null,
    userGrid: [],
    selectedCell: null, // {r, c}
    activeWordId: null,
    direction: 'horizontal',
    solvedWords: [],
    gameMessage: null
};

// --- ЛОГИКА ГЕНЕРАЦИИ ---
const generateCrossword = (wordsInput) => {
    const sortedWords = [...wordsInput].sort((a, b) => b.word.length - a.word.length);
    const gridSize = 20;
    const grid = Array(gridSize).fill(null).map(() => Array(gridSize).fill(null));
    const placedWords = [];

    const canPlaceWord = (word, row, col, direction) => {
        if (direction === 'horizontal') {
            if (col + word.length > gridSize) return false;
            for (let i = 0; i < word.length; i++) {
                const cell = grid[row][col + i];
                if (cell && cell !== word[i]) return false;
            }
        } else {
            if (row + word.length > gridSize) return false;
            for (let i = 0; i < word.length; i++) {
                const cell = grid[row + i][col];
                if (cell && cell !== word[i]) return false;
            }
        }
        return true;
    };

    const placeWord = (wordObj, row, col, direction) => {
        const { word } = wordObj;
        for (let i = 0; i < word.length; i++) {
            if (direction === 'horizontal') {
                grid[row][col + i] = word[i];
            } else {
                grid[row + i][col] = word[i];
            }
        }
        placedWords.push({
            ...wordObj,
            row,
            col,
            direction,
            id: placedWords.length + 1,
            length: word.length
        });
    };

    // Центрируем первое слово
    if(sortedWords.length > 0) {
        const firstWord = sortedWords[0];
        placeWord(firstWord, Math.floor(gridSize / 2), Math.floor((gridSize - firstWord.word.length) / 2), 'horizontal');
    }

    for (let i = 1; i < sortedWords.length; i++) {
        const currentWordObj = sortedWords[i];
        const currentWord = currentWordObj.word;
        let placed = false;

        for (const placedWord of placedWords) {
            if (placed) break;
            for (let j = 0; j < placedWord.length; j++) {
                const charOnBoard = placedWord.word[j];
                for (let k = 0; k < currentWord.length; k++) {
                    if (currentWord[k] === charOnBoard) {
                        const newDirection = placedWord.direction === 'horizontal' ? 'vertical' : 'horizontal';
                        let newRow, newCol;
                        if (newDirection === 'vertical') {
                            newRow = placedWord.row - k;
                            newCol = placedWord.col + j;
                        } else {
                            newRow = placedWord.row + j;
                            newCol = placedWord.col - k;
                        }
                        if (newRow >= 0 && newCol >= 0 && canPlaceWord(currentWord, newRow, newCol, newDirection)) {
                            placeWord(currentWordObj, newRow, newCol, newDirection);
                            placed = true;
                            break;
                        }
                    }
                }
                if (placed) break;
            }
        }
    }

    let minRow = gridSize, maxRow = 0, minCol = gridSize, maxCol = 0;
    let hasContent = false;
    for(let r=0; r<gridSize; r++) {
        for(let c=0; c<gridSize; c++) {
            if(grid[r][c]) {
                hasContent = true;
                if(r < minRow) minRow = r;
                if(r > maxRow) maxRow = r;
                if(c < minCol) minCol = c;
                if(c > maxCol) maxCol = c;
            }
        }
    }

    if (!hasContent) return { grid: [], placedWords: [], rows: 0, cols: 0 };

    const finalRows = maxRow - minRow + 1;
    const finalCols = maxCol - minCol + 1;
    const finalGrid = Array(finalRows).fill(null).map(() => Array(finalCols).fill(null));

    placedWords.forEach(pw => {
        pw.row -= minRow;
        pw.col -= minCol;
        for(let i=0; i<pw.length; i++) {
            const r = pw.direction === 'horizontal' ? pw.row : pw.row + i;
            const c = pw.direction === 'horizontal' ? pw.col + i : pw.col;
            if (!finalGrid[r][c]) {
                finalGrid[r][c] = { char: pw.word[i], wordIds: [] };
            }
            finalGrid[r][c].wordIds.push(pw.id);
        }
    });

    return { grid: finalGrid, placedWords, rows: finalRows, cols: finalCols };
};

const calculateBullsAndCows = (guessWord, targetWord) => {
    const guess = guessWord.toUpperCase().split('');
    const target = targetWord.toUpperCase().split('');
    const length = target.length;
    let bulls = 0, cows = 0;
    const guessFlags = Array(length).fill(false);
    const targetFlags = Array(length).fill(false);

    for (let i = 0; i < length; i++) {
        if (guess[i] === target[i]) {
            bulls++;
            guessFlags[i] = true;
            targetFlags[i] = true;
        }
    }
    for (let i = 0; i < Math.min(guess.length, length); i++) {
        if (guessFlags[i]) continue;
        for (let j = 0; j < length; j++) {
            if (!targetFlags[j] && guess[i] === target[j]) {
                cows++;
                targetFlags[j] = true;
                break;
            }
        }
    }
    return { bulls, cows };
};

// --- UI ФУНКЦИИ ---

const initGame = () => {
    const data = generateCrossword(WORD_DATA);
    state.layout = data;
    state.userGrid = Array(data.rows).fill(null).map(() => Array(data.cols).fill(''));
    state.selectedCell = null;
    state.activeWordId = null;
    state.direction = 'horizontal';
    state.solvedWords = [];
    state.gameMessage = null;
    
    renderAll();
};

const getActiveWordData = () => {
    if (!state.activeWordId || !state.layout) return null;
    return state.layout.placedWords.find(w => w.id === state.activeWordId);
};

const handleCellClick = (r, c) => {
    const cellData = state.layout.grid[r][c];
    if (!cellData) return;

    let newWordId = state.activeWordId;
    let newDirection = state.direction;

    if (state.selectedCell && state.selectedCell.r === r && state.selectedCell.c === c) {
        newDirection = state.direction === 'horizontal' ? 'vertical' : 'horizontal';
    }

    const possibleWords = state.layout.placedWords.filter(w => cellData.wordIds.includes(w.id));
    const wordInDirection = possibleWords.find(w => w.direction === newDirection);
    
    if (wordInDirection) {
        newWordId = wordInDirection.id;
    } else if (possibleWords.length > 0) {
        newWordId = possibleWords[0].id;
        newDirection = possibleWords[0].direction;
    }

    state.selectedCell = { r, c };
    state.direction = newDirection;
    state.activeWordId = newWordId;
    state.gameMessage = null;

    // Фокус на скрытый инпут
    const hiddenInput = document.getElementById('hidden-input');
    hiddenInput.focus();

    renderGrid();
    renderControlPanel();
    renderWordsList();
};

const handleInput = (key) => {
    if (!state.selectedCell) return;
    const { r, c } = state.selectedCell;

    if (key === 'Backspace') {
        state.userGrid[r][c] = '';
        moveCursor(-1);
    } else if (key.length === 1 && key.match(/[а-яА-Яa-zA-Z]/)) {
        state.userGrid[r][c] = key.toUpperCase();
        moveCursor(1);
    } else if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight'].includes(key)) {
        navigateGrid(key);
    }
    renderGrid();
};

const navigateGrid = (key) => {
    if(!state.selectedCell) return;
    let { r, c } = state.selectedCell;
    if (key === 'ArrowUp') r--;
    if (key === 'ArrowDown') r++;
    if (key === 'ArrowLeft') c--;
    if (key === 'ArrowRight') c++;

    if (r >= 0 && r < state.layout.rows && c >= 0 && c < state.layout.cols && state.layout.grid[r][c]) {
        handleCellClick(r, c);
    }
};

const moveCursor = (step) => {
    const activeWord = getActiveWordData();
    if (!activeWord) return;
    
    let currentIndex = -1;
    if (activeWord.direction === 'horizontal') {
        currentIndex = state.selectedCell.c - activeWord.col;
    } else {
        currentIndex = state.selectedCell.r - activeWord.row;
    }

    let nextIndex = currentIndex + step;
    if (nextIndex >= 0 && nextIndex < activeWord.length) {
        const nextR = activeWord.direction === 'horizontal' ? activeWord.row : activeWord.row + nextIndex;
        const nextC = activeWord.direction === 'horizontal' ? activeWord.col + nextIndex : activeWord.col;
        state.selectedCell = { r: nextR, c: nextC };
    }
};

const checkBullsAndCows = () => {
    const activeWord = getActiveWordData();
    if (!activeWord) return;

    let userInput = "";
    for (let i = 0; i < activeWord.length; i++) {
        const r = activeWord.direction === 'horizontal' ? activeWord.row : activeWord.row + i;
        const c = activeWord.direction === 'horizontal' ? activeWord.col + i : activeWord.col;
        userInput += state.userGrid[r][c] || " ";
    }
    userInput = userInput.trim();
    const targetWord = activeWord.word;

    if (userInput.length !== targetWord.length) {
        state.gameMessage = { type: 'error', text: `Заполните все буквы слова (${targetWord.length} букв)!` };
    } else {
        const result = calculateBullsAndCows(userInput, targetWord);
        if (result.bulls === targetWord.length) {
            state.gameMessage = { type: 'success', text: `Поздравляем! Слово "${targetWord}" разгадано верно!` };
            if (!state.solvedWords.includes(state.activeWordId)) {
                state.solvedWords.push(state.activeWordId);
            }
            renderGrid();
            renderWordsList();
        } else {
            state.gameMessage = { 
                type: 'info', 
                text: `Быки (верно и на месте): ${result.bulls}, Коровы (верно, но не там): ${result.cows}` 
            };
        }
    }
    renderControlPanel();
};

// --- ОТРИСОВКА (RENDER) ---

const renderGrid = () => {
    const container = document.getElementById('grid-container');
    container.innerHTML = '';
    
    container.style.display = 'grid';
    container.style.gridTemplateRows = `repeat(${state.layout.rows}, 36px)`;
    container.style.gridTemplateColumns = `repeat(${state.layout.cols}, 36px)`;
    container.style.gap = '2px';

    state.layout.grid.forEach((row, rIndex) => {
        row.forEach((cell, cIndex) => {
            const div = document.createElement('div');
            
            if (!cell) {
                div.className = 'bg-transparent';
            } else {
                const isSelected = state.selectedCell?.r === rIndex && state.selectedCell?.c === cIndex;
                const isRelated = state.activeWordId && cell.wordIds.includes(state.activeWordId);
                const isSolved = cell.wordIds.every(id => state.solvedWords.includes(id));

                let bgColor = 'bg-white';
                if (isSelected) bgColor = 'bg-indigo-200';
                else if (isRelated) bgColor = 'bg-indigo-50';
                else if (isSolved) bgColor = 'bg-green-50';

                let textColor = isSolved ? 'text-green-700' : 'text-slate-800';

                div.className = `cell-anim ${bgColor} border border-gray-300 flex items-center justify-center text-lg font-bold cursor-pointer select-none ${textColor}`;
                div.textContent = state.userGrid[rIndex][cIndex];
                div.onclick = () => handleCellClick(rIndex, cIndex);
            }
            container.appendChild(div);
        });
    });
};

const renderControlPanel = () => {
    const activeWord = getActiveWordData();
    const contentDiv = document.getElementById('control-panel-content');
    const msgDiv = document.getElementById('game-message');

    if (activeWord) {
        const dirText = activeWord.direction === 'horizontal' ? 'По горизонтали' : 'По вертикали';
        contentDiv.innerHTML = `
            <p class="text-sm mb-3 text-gray-600">
                Выделено: <span class="font-bold">${activeWord.length} букв</span> (${dirText})
            </p>
            <button id="check-btn" class="w-full bg-indigo-600 hover:bg-indigo-700 text-white py-2 px-4 rounded-lg font-medium transition flex justify-center items-center gap-2">
                <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M22 11.08V12a10 10 0 1 1-5.93-9.14"/><polyline points="22 4 12 14.01 9 11.01"/></svg>
                Проверить (Быки/Коровы)
            </button>
        `;
        document.getElementById('check-btn').onclick = checkBullsAndCows;
    } else {
        contentDiv.innerHTML = `<p class="text-sm text-gray-400 italic">Выберите слово в сетке, чтобы проверить его.</p>`;
    }

    if (state.gameMessage) {
        msgDiv.classList.remove('hidden', 'bg-green-100', 'border-green-200', 'text-green-800', 'bg-red-100', 'border-red-200', 'text-red-800', 'bg-blue-100', 'border-blue-200', 'text-blue-800');
        
        let classes = [];
        if (state.gameMessage.type === 'success') classes = ['bg-green-100', 'border-green-200', 'text-green-800'];
        else if (state.gameMessage.type === 'error') classes = ['bg-red-100', 'border-red-200', 'text-red-800'];
        else classes = ['bg-blue-100', 'border-blue-200', 'text-blue-800'];
        
        msgDiv.classList.add(...classes);
        msgDiv.textContent = state.gameMessage.text;
    } else {
        msgDiv.classList.add('hidden');
    }
};

const renderWordsList = () => {
    const container = document.getElementById('words-list-container');
    container.innerHTML = '';

    const sortedWords = [...state.layout.placedWords].sort((a, b) => a.id - b.id);

    sortedWords.forEach(wordObj => {
        const isActive = state.activeWordId === wordObj.id;
        const isSolved = state.solvedWords.includes(wordObj.id);
        
        const div = document.createElement('div');
        div.className = `
            p-4 rounded-xl border transition-all duration-200 cursor-pointer
            ${isActive ? 'border-indigo-500 bg-indigo-50 ring-2 ring-indigo-200 shadow-md' : 'border-gray-200 bg-white hover:border-indigo-300'}
            ${isSolved ? 'opacity-60 bg-green-50 border-green-200' : ''}
        `;
        
        div.onclick = () => {
            state.activeWordId = wordObj.id;
            state.direction = wordObj.direction;
            state.selectedCell = { r: wordObj.row, c: wordObj.col };
            state.gameMessage = null;
            document.getElementById('hidden-input').focus();
            renderGrid();
            renderControlPanel();
            renderWordsList();
        };

        const dirBadgeClass = wordObj.direction === 'horizontal' ? 'bg-blue-100 text-blue-700' : 'bg-purple-100 text-purple-700';
        const dirText = wordObj.direction === 'horizontal' ? 'По горизонтали' : 'По вертикали';
        
        let solvedBadge = '';
        if (isSolved) {
            solvedBadge = `<span class="text-xs font-bold text-green-600 flex items-center gap-1"><svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><polyline points="20 6 9 17 4 12"/></svg> Разгадано</span>`;
        }

        div.innerHTML = `
            <div class="flex justify-between items-start mb-2">
                <span class="text-xs font-bold px-2 py-1 rounded uppercase tracking-wider ${dirBadgeClass}">${dirText}</span>
                ${solvedBadge}
            </div>
            <p class="text-slate-700 font-medium leading-relaxed mb-3">${wordObj.desc}</p>
            <a href="${wordObj.videoUrl}" target="_blank" class="inline-flex items-center gap-2 text-sm text-red-600 hover:text-red-700 hover:underline font-medium bg-red-50 hover:bg-red-100 px-3 py-1.5 rounded-full transition-colors w-fit action-link">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"/><polygon points="10 8 16 12 10 16 10 8"/></svg>
                Посмотреть видео-подсказку
            </a>
        `;

        const link = div.querySelector('.action-link');
        link.onclick = (e) => e.stopPropagation();

        container.appendChild(div);
    });
};

const renderAll = () => {
    renderGrid();
    renderControlPanel();
    renderWordsList();
};

// --- EVENTS SETUP ---
document.addEventListener('DOMContentLoaded', () => {
    initGame();

    document.getElementById('restart-btn').addEventListener('click', initGame);
    
    // ИСПРАВЛЕННАЯ ОБРАБОТКА ВВОДА
    document.addEventListener('keydown', (e) => {
        // Если нажата навигация или Backspace - предотвращаем стандартное поведение и обрабатываем
        if (['ArrowUp', 'ArrowDown', 'ArrowLeft', 'ArrowRight', 'Backspace'].includes(e.key)) {
             e.preventDefault(); 
             handleInput(e.key);
             return;
        }

        // Если нажата буква
        if (e.key.length === 1 && e.key.match(/[а-яА-Яa-zA-Z]/)) {
            // Предотвращаем передачу события в скрытый input (чтобы не было дубля)
            // Это исправит проблему на ПК, где отрабатывает и keydown и input
            e.preventDefault();
            handleInput(e.key);
        }
    });
    
    // Слушатель для скрытого инпута (для мобильных, где keydown часто не дает код клавиши)
    const hiddenInput = document.getElementById('hidden-input');
    hiddenInput.addEventListener('input', (e) => {
        const char = e.target.value.slice(-1); 
        if (char) handleInput(char);
        e.target.value = ''; 
    });
});

</script>
</body>
</html>
